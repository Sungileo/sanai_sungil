---
title: "Geocomputation with R"
description: Creative & Experimental geography
categories: R
date: 2023/03/22
date-modified: 2023/04/22
image: "geo.png"
---

```{r}
#|warning: False
```

## Packages

```{r}
library(sf)
library(raster)
library(spData)
library(spDataLarge)
```

# 벡터 데이터

R class의 벡터 데이터와 다른 의미의, 공간 위치데이터의 점,선,면을 나타내는 데이터

```{r}
vignette(package = "sf") 
```

## World dataset from spData Package

```{r}
world %>% head()
names(world)
plot(world)
```

sp 데이터는 `st_as_sf()`로 sf 형식으로 변환

```{r}
library(sp)

world_sp = as(world, Class = "Spatial")

world_sf = st_as_sf(world_sp)
```

## Plot map

```{r}
plot(world["continent"])
```

### `st_union()` 공간정보 합치기

```{r}
world_asia = world[world$continent == "Asia", ]
asia = st_union(world_asia)

plot(world["pop"], reset = FALSE)
plot(asia, add = TRUE, col = "red")
```

### `st_centroid()`공간정보의 중심점 계산

cex : symbol size = sqrt(인구수)/1000

```{r}
plot(world["continent"], reset = FALSE)
cex = sqrt(world$pop) / 10000  
world_cents = st_centroid(world, of_largest = TRUE)
plot(st_geometry(world_cents), add = TRUE, cex = cex)
```

### Highlight

```{r}
india = world[world$name_long == "India", ]
plot(st_geometry(india), expandBB = c(0.1, 0.1, 0.1, 0.1), col = "gray", lwd = 3)
plot(world_asia[0], add = TRUE)
```

## Geometry types

```{r}
st_point(c(5, 2, 3, 1)) %>% plot()

multipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))
st_multipoint(multipoint_matrix) %>% plot()


linestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))
st_linestring(linestring_matrix) %>% plot()


polygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
st_polygon(polygon_list) %>% plot()


polygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))
polygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))
polygon_with_hole_list = list(polygon_border, polygon_hole)
st_polygon(polygon_with_hole_list) %>% plot()


multilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                            rbind(c(1, 2), c(2, 4)))
st_multilinestring((multilinestring_list)) %>% plot()


multipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),
                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))
st_multipolygon(multipolygon_list) %>% plot()


gemetrycollection_list = list(st_multipoint(multipoint_matrix),
                              st_linestring(linestring_matrix))
st_geometrycollection(gemetrycollection_list) %>% plot()
```

## Simple feature columns (sfc)

### `st_sfc()` 지리 특성을 하나의 컬럼 객체로 합침

point

```{r}
point1 = st_point(c(5, 2))
point2 = st_point(c(1, 3))
points_sfc = st_sfc(point1, point2)
points_sfc %>% plot()
```

polygon

```{r}
polygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
polygon1 = st_polygon(polygon_list1)
polygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))
polygon2 = st_polygon(polygon_list2)
polygon_sfc = st_sfc(polygon1, polygon2)
polygon_sfc %>% plot()
```

multilinestring

```{r}
multilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                             rbind(c(1, 2), c(2, 4)))
multilinestring1 = st_multilinestring((multilinestring_list1))
multilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), 
                             rbind(c(1, 7), c(3, 8)))
multilinestring2 = st_multilinestring((multilinestring_list2))
multilinestring_sfc = st_sfc(multilinestring1, multilinestring2)
multilinestring_sfc %>% plot()
```

geometry

```{r}
point_multilinestring_sfc = st_sfc(point1, multilinestring1)
point_multilinestring_sfc %>% plot()
```

### sfc 객체는 CRS에 대한 정보를 추가로 저장할 수 있음

CRS(coordinate reference systems, 좌표계시스템)

EPSG : European Petroleum Survey Group, 지도 투영과 datums 에 대한 좌표계 정보 데이터베이스를 제공

```{r}
st_crs(points_sfc)

points_sfc_wgs = st_sfc(point1, point2, crs = 4326)
st_crs(points_sfc_wgs)
```

## 위치데이터 + 속성데이터

`st_sf()` 를 이용하여 sfc와 class sf의 객체들을 하나로 통합할 수 있음

```{r}
lnd_point = st_point(c(0.1, 51.5))                 # sfg object
lnd_geom = st_sfc(lnd_point, crs = 4326)           # sfc object
lnd_attrib = data.frame(                           # data.frame object
  name = "London",
  temperature = 25,
  date = as.Date("2017-06-21")
)
lnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # sf object
lnd_sf
```

# Raster 데이터

```{r}
#install.packages("rgdal") 
library(rgdal)

raster_filepath = system.file("raster/srtm.tif", package = "spDataLarge") 
new_raster = raster(raster_filepath)

new_raster

plot(new_raster)
```

### RasterLayer class

한개의 층

Default CRS = WGS84 (resolution scale = degrees)

8\*8 Raster data

```{r}
my_raster = raster(nrows = 8, ncols = 8, res = 0.5, 
                   xmn = -2.0, xmx = 2.0, ymn = -2.0, ymx = 2.0, vals = 1:64)
nlayers(my_raster)
## plotting 
plot(my_raster)
```

### RasterBrick class

muliple layers

단일 다중 스펙트럼 위성 파일 (a single multispectral satellite file)

```{r}
multi_raster_file = system.file("raster/landsat.tif", package = "spDataLarge")
r_brick = brick(multi_raster_file)

nlayers(r_brick)

plot(r_brick)
```

### RasterStack class

multiple layer

메모리의 단일 다층 객체 (a single multilayer object in memory)

```{r}
raster_on_disk = raster(r_brick, layer = 1)
raster_in_memory = raster(xmn = 301905, xmx = 335745,
                          ymn = 4111245, ymx = 4154085, 
                          res = 30)
values(raster_in_memory) = sample(seq_len(ncell(raster_in_memory)))
crs(raster_in_memory) = crs(raster_on_disk) #같은 좌표 입력

r_stack = stack(raster_in_memory, raster_on_disk)
r_stack

plot(r_stack)
```

## CRS

지리좌표계

-   위,경도

-   각도로거리 측정

투영좌표계

-   "평평한 표면"위의 데카르트 좌표 기반

-   원점, x,y축

-   m와 같은 선형 측정 단위

### CRS in R

-   `epsg`코드
    -   일반적으로 짧음
    -   잘 정의된 좌표 시스템 하나만을 참조
-   `proj4string` 정의
    -   투영 우형, 데이텀 및 타원체와 같은 매개변수를 지정할때 더 많은 유연성
    -   다양한 투영 우형 지정, 기존 유형 수정 가능

`st_crs()`로 좌표계 조회

`st_set_crs()`로 좌표계 변경

```{r}
vector_filepath = system.file("vector/zion.gpkg", package = "spDataLarge")
new_vector = st_read(vector_filepath)
## st_read() : read vector dataset in R sf package

st_crs(new_vector)
```

Raster 데이터에서 좌표계

`projection()` 함수로 확인하거나 설정

```{r}
raster_filepath = system.file("raster/srtm.tif", package = "spDataLarge") 
new_raster = raster(raster_filepath) 
projection(new_raster)
```

변경

```{r}
new_raster3  <-  new_raster
projection(new_raster3) <-  "+proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 
                            +units=m +no_defs"
```

## 단위

sf 객체 내에 단위가 들어가있음

`st_area()` \[m\^2\] 단위 같이 반환

`set_units(st_object,units)` 로 반환 단위 설정

```{r}
names(world)
luxembourg = world[world$name_long == "Luxembourg", ]
south_korea = world[world$name_long == "Republic of Korea", ] 


st_area(luxembourg)
st_area(south_korea)
```

Raster는 단위에 대한 속성 정보가 없음

## 벡터 속성 조작

```{r}
library(tidyr)
library(dplyr)
```

`st_drop_geometry()` sf객체에서 속성 데이터만 가져오기

```{r}
dim(world)

world_df = st_drop_geometry(world)
class(world_df)
dim(world_df)
```

### Base R, dplyr 구문으로 조작

```{r}
world %>% 
  filter(continent == "Asia") %>% 
  select(name_long) %>% 
  plot()
```

```{r}
world_agg1  <-  aggregate(pop ~ continent, FUN = sum, data = world, na.rm = TRUE)
world_agg1
str(world_agg1)
class(world_agg1)
```

`aggregate()`함수를 사용해서 속성 데이터를 그룹별로 집계

-   world\$pop 은 sf객체가 아닌 숫자형 객체, geometry 정보는 없음

```{r}
world_agg2  <-  aggregate(world["pop"], by = list(world$continent),
                       FUN = sum, na.rm = TRUE)
class(world_agg2)
class(world['pop'])
class(world$pop)
```

`group_by()` 사용

```{r}
world_agg3 <- world %>% 
  group_by(continent) %>% 
  summarize(pop = sum(pop,na.rm = TRUE),n_countries = n())

world_agg3
```

인구 많은 3개 대륙

```{r}
world %>% 
  group_by(continent) %>% 
  summarize(pop = sum(pop, na.rm = TRUE), n_countries = n()) %>% 
  top_n(n = 3, wt = pop) %>%
  arrange(desc(pop)) %>%
  plot()
```

### `join` 가능

```{r}
world_coffee <-  left_join(world, coffee_data)

class(world_coffee)

names(world_coffee)
plot(world_coffee["coffee_production_2017"])
```

`setdiff()`로 일치하지 않는 열 식별

```{r}
setdiff(coffee_data$name_long, world$name_long)
```

stringr 패키지의 `str_subset()`

```{r}
library(stringr)
str_subset(world$name_long, "Dem*.+Congo")
```

```{r}
coffee_data$name_long[grepl("Congo,", coffee_data$name_long)]  <-  
  str_subset(world$name_long, "Dem*.+Congo")

world_coffee_match <- inner_join(world, coffee_data)

nrow(world_coffee_match)
```

### 새로운 열 만들기

base R, `mutate()`, `transmute()` 구문 사용

```{r}
world %>% transmute(pop_dens = pop / area_km2) %>% head()
```

`unite()` 사용 열 합치기

`seperate()` 사용 열 분리

```{r}
world %>%
  unite("con_reg", continent:region_un, sep = ":", remove = TRUE) %>% head()

world_unite <- world %>%
  unite("con_reg", continent:region_un, sep = ":", remove = FALSE)
```

```{r}
world_unite %>% 
  separate("con_reg", c("continent", "region_un"), sep = ":") %>% head()
```

`rename()`, `setNames()` 가능

## Raster 속성 조작

R의 레스터 객체(raster objects)는 데이터 속성으로 `숫자형(numeric)`, `정수형(integer)`, `논리형(logical)`, `요인형(factor)` 데이터 유형을 지원하며, `문자형(character)`은 지원하지 않음

문자형으로 이루어진 범주형 변수 값(categorical variables' values)을 가지고 레스터 객체의 속성을 만들고 싶으면

-   먼저 문자형을 요인형으로 변환 (또는 논리형으로 변환)하고

-   요인형 값을 속성 값으로 해서 레스터 객체를 만듬

```{r}
elev <- raster(nrows = 6, # integer > 0. Number of rows 
               ncols = 6, # integer > 0. Number of columns 
               #res = 0.5, # numeric vector of length 1 or 2 to set the resolution 
               xmn = -1.5, # minimum x coordinate (left border) 
               xmx = 1.5, # maximum x coordinate (right border) 
               ymn = -1.5, # minimum y coordinate (bottom border) 
               ymx = 1.5, # maximum y coordinate (top border) 
               vals = 1:36) # values for the new RasterLayer 

elev

plot(elev, main = 'raster datasets with numeric valeus')
```

`factor` 형식으로 변환

```{r}
grain_order <- c("clay", "silt", "sand")
grain_char <- sample(grain_order, 36, replace = TRUE)
grain_fact <- factor(grain_char, levels = grain_order)
grain <- raster(nrows = 6, ncols = 6, res = 0.5, 
               xmn = -1.5, xmx = 1.5, ymn = -1.5, ymx = 1.5,
               vals = grain_fact)
plot(grain)
```

`factor` 추가

```{r}
levels(grain)[[1]] <- cbind(levels(grain)[[1]], wetness = c("wet", "moist", "dry"))
levels(grain)

grain[c(1, 11, 35)]
factorValues(grain, grain[c(1, 11, 35)])
```

## 공간 부분 집합

`st_disjoint`는 sf 패키지에 포함된 함수로, 스페이스 객체끼리 겹치지 않는 부분을 반환하는 함수.

따라서, `canterbury`와 공간적으로 겹치지 않는 부분에 대해서만 `nz_height` 객체에서 값을 선택

```{r}
canterbury  <-  nz %>% filter(Name == "Canterbury")
canterbury_height <-  nz_height[canterbury, ]

nz_height[canterbury, 2, op = st_disjoint]
plot(nz_height[canterbury, 2, op = st_disjoint])
```

`st_intersects()` 를 활용한 공간 부분 집합 추출

```{r}
sel_sgbp <-  st_intersects(x = nz_height, y = canterbury)

sel_logical  <-  lengths(sel_sgbp) > 0

canterbury_height2 <-  nz_height[sel_logical, ]

canterbury_height3  <-  nz_height %>%
  filter(st_intersects(x = ., y = canterbury, sparse = FALSE))

class(sel_sgbp)

st_intersects(x = nz_height, y = canterbury)
```

### 위상관계

```{r}
# create a polygon
a_poly  <-  st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a <-   st_sfc(a_poly)
# create a line
l_line <-   st_linestring(x = matrix(c(-1, -1, -0.5, 1), ncol = 2))
l <-   st_sfc(l_line)
# create points
p_matrix <- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2)
p_multi <- st_multipoint(x = p_matrix)
p <- st_cast(st_sfc(p_multi), "POINT")

plot(a, col = c("gray"), border = c("red"))
plot(l,add = T)
plot(p,add = T)
box(col="black")

axis(side = 1, at = seq(-1.0, 1.0, 0.5), tck = 0.02)
axis(side = 2, at = seq(-1, 1, 0.5), tck = 0.02, las=1)
text(p_matrix,pos=1)
```

polygon과 point의 겹치는 부분을 반환

`st_intersects()` 겹치는 부분

```{r}
st_intersects(p, a)

st_intersects(p, a,sparse = F)[,1]
```

`st_within()` 완전히 위에 있는 부분

```{r}
st_within(p, a, sparse = FALSE)[, 1]
```

`st_touches()` 테두리만 반환

```{r}
st_touches(p, a, sparse = FALSE)[, 1]
```

`st_is_within_distance()` 는 삼각형에서 주어진 거리보다 가까운 객체들을 반환

```{r}
st_is_within_distance(p, a, dist = 0.9,sparse = F)
```
